# -*- coding: utf-8 -*-

#	STLIB IMPORT
from stlib.scene import MainHeader
from stlib.solver import DefaultSolver
from stlib.physics.deformable import ElasticMaterialObject
from stlib.physics.constraints import FixedBox
from stlib.animation import AnimationManager , animate

# SOFTROBOTS IMPORT
from softrobots.actuators import PullingCable

# MOR IMPORT
from mor.animation import DefaultShaking

nbActuator = 4
dt = 1
increment = [5]*nbActuator
breathTime = [20]*nbActuator
maxPull = [40]*nbActuator
nbIterations = [0]*nbActuator
stateFileName = "stateFile"

for i in range(nbActuator):
    nbIterations[i] = ((maxPull[i]/increment[i])-1)*breathTime[i]+ (maxPull[i]/increment[i])-1

timeExe = nbIterations[0] * dt
phase = [1,1,1,1]

actuatorsParam = [
		{'withName' : 'nord',
		 'withCableGeometry' : [[0, 97, 45]],
		 'withAPullPointLocation' : [0, 10, 30]
		},
		{'withName' : 'ouest',
		 'withCableGeometry' : [[-97, 0, 45]],
		 'withAPullPointLocation' : [-10, 0, 30]
		},
		{'withName' : 'sud',
		 'withCableGeometry' : [[0, -97, 45]],
		 'withAPullPointLocation' : [0, -10, 30]
		},
		{'withName' : 'est',
		 'withCableGeometry' : [[97, 0, 45]],
		 'withAPullPointLocation' : [10, 0, 30]
		}
	]

meshPath = '/home/felix/SOFA/plugin/ModelOrderReduction/examples/Model_Reduction/1_INPUT/Mesh_Model/'
tmp = [breathTime[0],breathTime[1],breathTime[2],breathTime[3]]
print "Scene Phase :",phase
print "Scene nbIterations :",nbIterations
print "timeExe :",timeExe

class SingletonTmp(object):
	def __init__(self, breathTime):
		self.tmp = list(breathTime)

mySingleton = SingletonTmp(breathTime)

def myAnimate(factor, **param):
	global tmp
	# actuatorMaxPull = maxPull[actuatorNb]
	# actuatorBreathTime = breathTime[actuatorNb]
	# actuatorIncrement = increment[actuatorNb]

	print "PLOP"

	for i in param :
		print i

	# if actuatorBreathTime == tmp[actuatorNb]:
	# 	actualValue = target.getObject('CableConstraint').findData('value').value[0][0]	
	# 	print(	"For Actuator : ", 		target.name,
	# 			"with actualValue :", 	actualValue)

	# 	if phaseTest[actuatorNb] == 1:
	# 		if actualValue < actuatorMaxPull:
	# 			print "		INCREMENT ++"
	# 			actualValue = actualValue + actuatorIncrement
	# 		else:
	# 			print "Done for :",target.name
	# 	else:
	# 		if actualValue >= actuatorIncrement:
	# 			print "		INCREMENT --"
	# 			actualValue = actualValue - actuatorIncrement
	# 		else:
	# 			print "Done for :",target.name

	# 	print "Updated Value :",actualValue
	# 	target.getObject('CableConstraint').findData('value').value = actualValue
	# 	tmp[actuatorNb] = 0

	# else:
	# 	# print tmp[actuatorNb]
	# 	tmp[actuatorNb] += 1

def createScene(rootNode):

	rootNode = MainHeader(rootNode, plugins=["SofaPython","SoftRobots","ModelOrderReduction"], gravity=[0.0,0.0,-9810], dt=dt)

	modelNode = ElasticMaterialObject(
		attachedTo=rootNode,
		volumeMeshFileName=meshPath+'siliconeV0.vtu',
		name='modelNode',
        rotation=[90, 0.0, 0.0],
        translation=[0.0, 0.0, 35],
		totalMass=0.5,
		withConstrain=False,
		poissonRatio=0.45,
		youngModulus=450)
	
	modelNode.createObject('GenericConstraintCorrection', solverName='Solver')
	modelNode.createObject('WriteState', filename=stateFileName+".state", period='1',writeX="1", writeX0="", writeV="0") 
    
	FixedBox(
		atPositions=[-15, -15, -40,  15, 15, 10],
		applyTo=modelNode,
		doVisualization=True) 	

	AnimationManager(modelNode)

	for i in range(len(actuatorsParam)):
		cable = PullingCable(
					attachedTo=modelNode,
					name=actuatorsParam[i]['withName'],
					cableGeometry=actuatorsParam[i]['withCableGeometry'],
					pullPointLocation=actuatorsParam[i]['withAPullPointLocation'],
					valueType="displacement")

		animate(DefaultShaking, {
							"target" : cable ,
							"phaseTest" : phase, 
							"actuatorNb" : i,
							"actuatorMaxPull" : maxPull[i],
							"actuatorBreathTime" : breathTime[i],
							"actuatorIncrement" : increment[i],
							"breathTimeCounter" : mySingleton}, timeExe)

	return rootNode 